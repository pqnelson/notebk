\chapter{Theorems and Lisp}

\M
It turns out that rewriting S-expressions suffices as the basis for a
theorem prover, which is precisely how ACL2 works. Carl Eastlund and
Daniel Friedman's \textit{The Little Prover} discuss a ``toy model'' of
such a prover for the Scheme dialect. The terminology is a little
strange at first, but the idea is to apply theorems to rewrite
subexpressions (called the \define{Focus}) until the result is
\lstinline[language=lisp]{t}. 

\M The precise description of the logic of ACL2 may be found in Kaufmann
and Moore's ``A Precise Description of the ACL2 Logic''.\footnote{Found online at \url{http://www.cs.utexas.edu/users/moore/publications/km97.pdf}}
There are 11 axioms which specify the Lisp primitives, which behave as
we would expect --- things like which branch of an ``if'' expression to
take depending on the result of evaluating the test expression.

\begin{enumerate}
\item \lstinline[language=lisp]{(not (equal t nil))}
\item \lstinline[language=lisp]{(equal (if t x y) x)}
\item \lstinline[language=lisp]{(equal (if nil x y) y)}
\item \lstinline[language=lisp]{(equal (consp (cons x y)) t)}
\item \lstinline[language=lisp]{(equal (consp nil) nil)}
\item \lstinline[language=lisp]{(equal (car (cons x y)) x)}
\item \lstinline[language=lisp]{(equal (cdr (cons x y)) y)}
\item \lstinline[language=lisp]{(implies (equal (consp x) t) (equal (cons (car x) (cdr x)) x))}
  %\item \lstinline[language=lisp]{}
\end{enumerate}

\M We can implement a ``poor man's quasiquote'' which can be used to
define a proposition to produce a formula parametrized by variables.

\begin{lisp-example}
(defun poor-man-quasiquote (e arglist &optional (cdr? nil))
  (cond
    ((and (symbolp e)
          (find e arglist)) e)
    ((consp e) (let ((result (cons (poor-man-quasiquote (car e) arglist)
                                   (if (endp (cdr e))
                                       nil
                                       (poor-man-quasiquote (cdr e) arglist 't)))))
                 (if cdr?
                     result
                     (cons 'list result))))
    (t (list 'quote e))))

;; (poor-man-quasiquote '(= x x) '(x))
;; (poor-man-quasiquote '(implies (and (= x y) (= y z)) (= x z)) '(x y z))

(defmacro defproposition (name arglist e)
  (let ((body (poor-man-quasiquote e arglist)))
    `(defun ,name ,arglist ,body)))
\end{lisp-example}
